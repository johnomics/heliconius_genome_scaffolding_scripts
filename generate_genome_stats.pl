#!/usr/bin/env perl

# generate_genome_stats.pl
#
# This script is provided FOR INFORMATION ONLY and is not intended for use.
# It was written specifically for the Heliconius melpomene genome paper
# (Heliconius Genome Consortium, doi: 10.1038/nature11041) and has not
# been adapted for general use.

# Purpose: Take whole genome chromosome AGP file
#          and whole genome scaffold AGP file
#          and output genome statistics including superscaffolding information

# Input  : chromosome AGP file generated by revise_chromosome_AGP.pl
#          scaffold AGP file generated by scaffold_heliconius_genome.pl

# Output : summary tables of genome statistics

# Author: John Davey john.davey@ed.ac.uk
# Begun 14/12/11

#############################################################################
###                                                                       ###
###                                 CODE                                  ###
###                                                                       ###
#############################################################################

use strict;
use warnings;
use Carp;
use English;
use Getopt::Long;
use Data::Dumper;
use List::Util qw/min max/;

# Autoflush output so reporting on progress works
$| = 1;

my $chr_agp_filename = "";
my $scf_agp_filename = "";

my $options_okay = GetOptions(
    'chr_agp=s' => \$chr_agp_filename,
    'scf_agp=s' => \$scf_agp_filename,
);

croak
"\nUsage: perl generate_genome_stats.pl -c chr_agp_filename -s scf_agp_filename\n"
  if !$options_okay;

croak "No chromosome AGP file! Please specify -c $OS_ERROR\n"
  if ( $chr_agp_filename eq '' );
croak "No scaffold AGP file! Please specify -s $OS_ERROR\n"
  if ( $scf_agp_filename eq '' );

open my $scf_agp, '<', $scf_agp_filename
  or croak "Can't open $scf_agp_filename: $OS_ERROR!\n";

my %scfs_all;
while ( my $scf_agp_line = <$scf_agp> ) {
    chomp $scf_agp_line;
    next if ($scf_agp_line =~ /^#/);
    my @agp_fields = split /\t/, $scf_agp_line;
    next if ( $agp_fields[4] eq 'N' );
    my $scf      = $agp_fields[0];
    my $ctg_size = $agp_fields[7];
    $scfs_all{$scf} += $ctg_size;
}
close $scf_agp;

print "Total len | Scfs | N50 | L50    | Description\n";
calculate_genome_stats( 'All scaffolds', \%scfs_all );

my %scfs_2kb;
map {
    if ( $scfs_all{$_} >= 2000 ) { $scfs_2kb{$_} = $scfs_all{$_} }
} keys %scfs_all;

calculate_genome_stats( 'All scaffolds >2kb', \%scfs_2kb );

open my $chr_agp, '<', $chr_agp_filename
  or croak "Can't open $chr_agp_filename: $OS_ERROR!\n";

my %on_map_scaffolds;
my %on_map_superscaffolds;
my %on_chr_scaffolds;
my %on_chr_superscaffolds;

my $superscf_id = 0;
my $anchor_flag = 0;
while ( my $chr_agp_line = <$chr_agp> ) {
    chomp $chr_agp_line;
    next if ($chr_agp_line =~ /^#/);
    my @agp_fields = split /\t/, $chr_agp_line;
    my $chr = $agp_fields[0];
    if ( $agp_fields[4] eq 'D' ) {
        my $scf     = $agp_fields[5];
        my $scf_len = $scfs_all{$scf};
        if ( !defined $on_chr_scaffolds{$chr} ) {
            $superscf_id++;
        }

        my $cM_count = 1;
        if ( defined $agp_fields[9] ) {
            my $comment = $agp_fields[9];
            $cM_count = ( scalar split /cM/, $comment ) - 1;
        }

        if ( ($anchor_flag) && ( $cM_count == 1 ) ) {
            $superscf_id++;
            $anchor_flag = 0;
        }

        if ( $cM_count > 1 ) { $anchor_flag++; }

        $on_map_scaffolds{$scf} = $scf_len;
        $on_chr_scaffolds{$chr}{$scf} = $scf_len;
        $on_map_superscaffolds{$superscf_id} += $scf_len;
        $on_chr_superscaffolds{$chr}{$superscf_id} += $scf_len;
    }

    elsif ( $agp_fields[4] eq 'N' ) {
        my $gap_type = ( defined $agp_fields[8] )
          ? substr $agp_fields[8], 2
          : 'unordered';
        if   ( $gap_type eq 'unordered' )     { $superscf_id++; }
        if   ( $gap_type eq 'recombination' ) { $anchor_flag++; }
        else                                  { $anchor_flag = 0; }
    }
}
close $chr_agp;

calculate_genome_stats( 'On map scaffolds',      \%on_map_scaffolds );
calculate_genome_stats( 'On map superscaffolds', \%on_map_superscaffolds );

my %on_map_superscaffolds_and_off_map_scaffolds;
my %on_map_superscaffolds_and_off_map_scaffolds_2kb;

map {
    $on_map_superscaffolds_and_off_map_scaffolds{$_} =
      $on_map_superscaffolds{$_};
    if ( $on_map_superscaffolds{$_} >= 2000 ) {
        $on_map_superscaffolds_and_off_map_scaffolds_2kb{$_} =
          $on_map_superscaffolds{$_};
    }
} keys %on_map_superscaffolds;

my %off_map_scaffolds;
map {
    if ( !defined $on_map_scaffolds{$_} )
    {
        print "Offmap:$_\n";
        $off_map_scaffolds{$_} = $scfs_all{$_};
        $on_map_superscaffolds_and_off_map_scaffolds{$_} = $scfs_all{$_};
        if ( $scfs_all{$_} >= 2000 ) {
            $on_map_superscaffolds_and_off_map_scaffolds_2kb{$_} =
              $scfs_all{$_};
        }

    }
} keys %scfs_all;

calculate_genome_stats('Off map scaffolds', \%off_map_scaffolds);

calculate_genome_stats(
    'On map superscaffolds and off map scaffolds',
    \%on_map_superscaffolds_and_off_map_scaffolds
);

calculate_genome_stats(
    'On map superscaffolds and off map scaffolds >=2Kb',
    \%on_map_superscaffolds_and_off_map_scaffolds_2kb
);

print "\n";
for my $i ( 1 .. 20 ) {
    calculate_genome_stats( "chr$i scaffolds", $on_chr_scaffolds{"chr$i"} );
}
calculate_genome_stats( "chrZ scaffolds", $on_chr_scaffolds{"chrZ"} );

print "\n";

for my $i ( 1 .. 20 ) {
    if ( defined $on_chr_scaffolds{"chr$i\_unmapped"} ) {
        calculate_genome_stats( "chr$i\_unmapped scaffolds",
            $on_chr_scaffolds{"chr$i\_unmapped"} );
    }
}
calculate_genome_stats( "chrZ_unmapped scaffolds",
    $on_chr_scaffolds{"chrZ_unmapped"} );




sub calculate_genome_stats {
    my ( $input_type, $scf_ref ) = @_;

    my $scf_num   = keys %{$scf_ref};
    my $total_len = 0;
    map { $total_len += $scf_ref->{$_}; } keys %{$scf_ref};

    my $l50;
    my $n50;
    my $cum_n50_len;

    foreach
      my $scf ( sort { $scf_ref->{$b} <=> $scf_ref->{$a} } keys %{$scf_ref} )
    {
        $cum_n50_len += $scf_ref->{$scf};
        $n50++;
        if ( $cum_n50_len >= ( $total_len / 2 ) ) {
            $l50 = $scf_ref->{$scf};
            last;
        }
    }

    printf "%9d | %4d | %3d | %6d | %s\n", $total_len, $scf_num, $n50, $l50,
      $input_type;

    return;
}
